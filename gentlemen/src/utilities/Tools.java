package utilities;

import org.jbox2d.common.Vec2;
import org.lwjgl.util.vector.Vector2f;

public class Tools {

	/**
	 * Wraps an angle to the range [0, TWO_PI)
	 * 
	 * @param angle
	 *            the angle to wrap
	 * @return the wrapped angle
	 */
	public static float wrapAngle(float angle) {
		angle = angle % Constants.TWO_PI;

		if (angle < 0.0f) {
			angle += Constants.TWO_PI;
		}

		return angle;
	}

	/**
	 * Calculates the closest delta (from->to) between two angles
	 * 
	 * @param from
	 *            from angle
	 * @param to
	 *            to angle
	 * @return the delta, in radians
	 */
	public static float closestAngleDelta(float from, float to) {
		from = wrapAngle(from);
		to = wrapAngle(to);

		final float directDelta = to - from;
		final float indirectDelta = -Math.signum(directDelta)
				* (Constants.TWO_PI - Math.abs(directDelta));

		if (Math.abs(directDelta) < Math.abs(indirectDelta)) {
			return directDelta;
		} else {
			return indirectDelta;
		}
	}

	/**
	 * Converts an angle to a unit vector.
	 * 
	 * @param angle
	 *            the angle that is to be converted to a Vector
	 * 
	 * @return the resulting unit vector
	 */
	public static Vector2f angleToVector(float angle) {
		final Vector2f resVec = new Vector2f();

		// Safety measures, ensures error-free computing later
		if (Float.isNaN(angle) || Float.isInfinite(angle)) {
			angle = 0.0f;
		}

		// Compute the x and y values of resVec
		resVec.x = (float) Math.cos(angle);
		resVec.y = (float) -Math.sin(angle);

		return resVec;
	}

	/**
	 * Converts a vector to an angle
	 * 
	 * @param vector
	 *            the vector
	 * @return an angle in the range [0, TWO_PI]
	 */
	public static float vectorToAngle(final Vector2f vector) {
		// Calculate the angle from the x-axis to the vector
		float angle = Vector2f.angle(vector, new Vector2f(1.0f, 0.0f));

		// Avoid error that can be generated by the Vector2f.angle() method
		if (Float.isNaN(angle) || Float.isInfinite(angle)) {
			angle = 0.0f;
		}

		// To take in to account if the angle is between PI and two PI
		if (vector.y > 0) {
			angle = Constants.TWO_PI - angle;
		}

		return angle;
	}

	/**
	 * Returns the delta vector between two points
	 * 
	 * @param source
	 *            the from point
	 * @param destination
	 *            the to point
	 * @return the delta
	 */
	public static Vector2f vectorBetween(final Vector2f source,
			final Vector2f destination) {

		final Vector2f resVect = new Vector2f();

		Vector2f.sub(destination, source, resVect);

		return resVect;
	}

	/**
	 * Returns the distance between two points
	 * 
	 * @param source
	 * @param destination
	 * @return the distance
	 */
	public static float distanceBetween(final Vector2f source,
			final Vector2f destination) {

		return vectorBetween(source, destination).length();
	}

	/**
	 * Converts a normal vector to a physics vector
	 * 
	 * @param input
	 *            the normal vector to convert
	 * @return the converted vector
	 */
	public static Vec2 toPhysicsVector(final Vector2f input) {
		return new Vec2(input.x, input.y);
	}

	/**
	 * Converts a physics vector to a normal vector
	 * 
	 * @param input
	 *            the physics vector to convert
	 * @return the converted vector
	 */
	public static Vector2f toNormalVector(final Vec2 input) {
		return new Vector2f(input.x, input.y);
	}
}
